{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"STMTools","text":"<p>STMTools (Space-Time Matrix Tools) is an Xarray extension for Space-Time Matrix operations (Bruna et al., 2021; van Leijen et al., 2021). It provides tools to read, write, enrich and manipulate a Space-Time Matrix (STM).</p> <p>An STM is a dataset containing data with a space (point, location) and time (epoch) component, as well as contextual data. STMTools utilizes Xarray\u2019s multi-dimensional labeling feature, and Zarr's chunk storage feature, to efficiently read and write large Space-Time matrices.</p> <p>The contextual data enrichment functionality is implemented with Dask. Therefore it can be performed in a paralleled style on High Performance Computing (HPC) systems.</p> <p>At this stage, STMTools specifically focuses on the implementation for radar interferometry measurements, e.g. Point Scatterers, Distributed Scatterers, etc, with the possibility to be extended to other measurements with space and time attributes.</p>"},{"location":"#references","title":"References","text":"<p>[1] Bruna, M. F. D., van Leijen, F. J., &amp; Hanssen, R. F. (2021). A Generic Storage Method for Coherent Scatterers and Their Contextual Attributes. In 2021 IEEE International Geoscience and Remote Sensing Symposium IGARSS: Proceedings (pp. 1970-1973). [9553453] (International Geoscience and Remote Sensing Symposium (IGARSS); Vol. 2021-July). IEEE . https://doi.org/10.1109/IGARSS47720.2021.9553453</p> <p>[2] van Leijen, F. J., van der Marel, H., &amp; Hanssen, R. F. (2021). Towards the Integrated Processing of Geodetic Data. In 2021 IEEE International Geoscience and Remote Sensing Symposium IGARSS: Proceedings (pp. 3995-3998). [9554887] IEEE . https://doi.org/10.1109/IGARSS47720.2021.9554887</p>"},{"location":"CHANGELOG/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file. This project adheres to Semantic Versioning.</p> <p>[0.1.0] - 2023-11-19</p> <ul> <li> <p>Added</p> <p>The first version of the STMTools package. The following functionalities are implemented:</p> <ul> <li>Data loading function from csv files;</li> <li>Subset function based on thresholding and polygons;</li> <li>Enrichment function from polygons;</li> <li>Dimension regulating function;</li> <li>Metadata registration function;</li> <li>Relevant docs and tests.</li> </ul> </li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>This code of conduct is adapted from the  Git Code of Conduct.</p>"},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Project maintainers are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at team-atlas@esciencecenter.nl.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All Project maintainers are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4,  available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p>"},{"location":"CONTRIBUTING/","title":"STMTools Contributing Guidelines","text":"<p>We welcome any kind of contribution to our software, from a simple comment  or question to a full fledged pull request.  Please read and follow our Code of Conduct.</p> <p>A contribution can be one of the following cases:</p> <ul> <li>you have a question;</li> <li>you think you may have found a bug (including unexpected behavior);</li> <li>you want to make some kind of change to the code base (e.g. to fix a bug, to add a new feature, to update documentation).</li> </ul> <p>The sections below outline the steps in each case.</p>"},{"location":"CONTRIBUTING/#you-have-a-question","title":"You have a question","text":"<ul> <li>use the search functionality in GitHub issue to see if someone already filed the same issue;</li> <li>if your issue search did not yield any relevant results, create a new issue;</li> <li>add the \"question\" label; include other labels when relevant.</li> </ul>"},{"location":"CONTRIBUTING/#you-think-you-may-have-found-a-bug","title":"You think you may have found a bug","text":"<ul> <li>use the search functionality in GitHub issue to see if someone already filed the same issue;</li> <li>if your issue search did not yield any relevant results, create a new issue, making sure to provide enough information to the rest of the community to understand the cause and context of the problem. Depending on the issue, you may want to include:<ul> <li>the SHA hashcode of the commit that is causing your problem;</li> <li>some identifying information (name and version number) for dependencies you're using;</li> <li>information about the operating system;</li> </ul> </li> <li>add relevant labels to the newly created issue.</li> </ul>"},{"location":"CONTRIBUTING/#you-want-to-make-some-kind-of-change-to-the-code-base","title":"You want to make some kind of change to the code base","text":"<ul> <li>(important) announce your plan to the rest of the community before you start working. This announcement should be in the form of a (new) issue;</li> <li>(important) wait until some kind of consensus is reached about your idea being a good idea;</li> <li>if needed, fork the repository to your own Github profile and create your own feature branch off of the latest master commit. While working on your feature branch, make sure to stay up to date with the master branch by pulling in changes, possibly from the 'upstream' repository (follow the instructions from GitHub: instruction 1: configuring a remote for a fork and instruction 2: syncing a fork);</li> <li>make sure the existing tests still work by running, e.g. <code>pytest tests</code>;</li> <li>add your own tests (if necessary);</li> <li>update or expand the documentation;</li> <li>make sure the linting tests pass by running <code>ruff</code> in the project root directory: <code>ruff check .</code>;</li> <li>push your feature branch to (your fork of) the stmtools repository on GitHub;</li> <li>create the pull request, e.g. following the instructions: creating a pull request.</li> </ul> <p>In case you feel like you've made a valuable contribution, but you don't know how to write or run tests for it, or how to generate the documentation: don't let this discourage you from making the pull request; we can help you! Just go ahead and submit the pull request, but keep in mind that you might be asked to append additional commits to your pull request.</p>"},{"location":"operations/","title":"Operations on STM","text":"<p>STMTools supports various operations on an STM.</p>"},{"location":"operations/#enrich-an-stm","title":"Enrich an STM","text":"<p>Contextual data can be added to an STM by enrichment. At present, STMTools supports enriching an STM by static polygons.</p> <p>For example, if soil type data (<code>soil_map.gpkg</code>) is available together with an STM, one can first read <code>soil_map.gpkg</code> using the <code>GeoPandas</code> library as a <code>GeoDataFrame</code>, then add the soil type and corresponding type ID to the STM, using the <code>enrich_from_polygon</code> function.</p> <p><pre><code>import geopandas as gpd\npolygon = gpd.read_file('soil_map.gpkg')\nfields_to_query = ['soil_type', 'type_id']\nstmat_enriched = stmat.stm.enrich_from_polygon(polygon, fields_to_query)\n</code></pre> Two attributes from <code>soil_map.gpkg</code>: <code>soil_type</code> and <code>type_id</code>, will be added as data variables to the STM.</p> <p>In case of a large file <code>soil_map.gpkg</code>, one can directly pass the file path to <code>enrich_from_polygon</code> to trigger the chunked enrichment:</p> <pre><code>path_polygon = Path('soil_map.gpkg')\nfields_to_query = ['soil_type', 'type_id']\nstmat_enriched = stmat.stm.enrich_from_polygon(path_polygon, fields_to_query)\n</code></pre>"},{"location":"operations/#subset-an-stm","title":"Subset an STM","text":"<p>A subset of an STM can be obtained based on 1) thresholding on an attribute, or 2) intersection with a background polygon.</p>"},{"location":"operations/#subset-by-an-attribute","title":"Subset by an attribute","text":"<p>For example, select entries with <code>pnt_enscoh</code> higher than 0.7:</p> <pre><code>stmat_subset = stmat.stm.subset(method=\"threshold\", var=\"pnt_enscoh\", threshold='&gt;0.7')\n</code></pre> <p>This is equivalent to Xarray filtering:</p> <pre><code>mask = stmat[\"pnt_enscoh\"] &gt; 0.7\nmask = mask.compute()\nstmat_subset = stmat.where(mask, drop=True)\n</code></pre>"},{"location":"operations/#subset-by-a-polygon","title":"Subset by a polygon","text":"<p>Select all entries inside the polygons in <code>example_polygon.shp</code>:</p> <pre><code>import geopandas as gpd\npolygon = gpd.read_file('example_polygon.shp')\nstm_demo.stm.subset(method='polygon', polygon=polygon)\n</code></pre> <p>Subset can also operate on the polygon file directly if the file is too big to load in the memory:</p> <pre><code>stmat_subset = stm_demo.stm.subset(method='polygon', polygon='example_polygon.gpkg')\n</code></pre>"},{"location":"operations/#regulate-the-dimensions-of-an-stm","title":"Regulate the dimensions of an STM","text":"<p>Use <code>regulate_dims</code> to add a missing <code>space</code> or <code>time</code> dimension.</p> <pre><code># An STM witout time dimension\nnspace = 10\nstm_only_space = xr.Dataset(data_vars=dict(data=([\"space\"], np.arange(nspace))))\n\nstm_only_space\n</code></pre> <pre><code>&lt;xarray.Dataset&gt;\nDimensions:  (space: 10)\nDimensions without coordinates: space\nData variables:\n    data     (space) int64 0 1 2 3 4 5 6 7 8 9\n</code></pre> <pre><code>stm_only_space.regulate_dims()\n</code></pre> <pre><code>&lt;xarray.Dataset&gt;\nDimensions:  (time: 1, space: 10)\nDimensions without coordinates: time, space\nData variables:\n    data     (space, time) int64 0 1 2 3 4 5 6 7 8 9\n</code></pre>"},{"location":"operations/#assign-metadata","title":"Assign metadata","text":"<p>Use <code>register_metadata</code> to assign metadata to an STM by a Python dictionary.</p> <pre><code>metadata_normal = dict(techniqueId=\"ID0001\", datasetId=\"ID_datasetID\", crs=4326)\nstmat_with_metadata = stmat.stm.register_metadata(metadata_normal)\n</code></pre>"},{"location":"setup/","title":"Installation","text":"<p>STMTools can be installed from PyPI:</p> <pre><code>pip install stmtools\n</code></pre> <p>or from the source:</p> <pre><code>git clone git@github.com:TUDelftGeodesy/stmtools.git\ncd stmtools\npip install .\n</code></pre> <p>Note that Python version <code>&gt;=3.10</code> is required for STMTools.</p>"},{"location":"setup/#tips","title":"Tips","text":"<p>We strongly recommend installing separately from your default Python environment. E.g. you can use environment manager e.g. mamba to create separate environment.</p>"},{"location":"stm_init/","title":"Initiate a Space-Time Matrix","text":"<p>We implemented STM in Python as an <code>Xarray.Dataset</code> object. An STM instance can be initiated as an <code>Xarray.Dataset</code> in different ways.</p> <p>STMTools provides a reader to perform lazy loading from a csv file. However, we recommend to store STM in <code>zarr</code> format, and directly load them as an Xarray object by <code>xarray.open_zarr</code>.</p>"},{"location":"stm_init/#manually-initiate-an-stm","title":"Manually initiate an STM","text":"<p>When represented by <code>xarray.Dataset</code>, an STM is a <code>Dataset</code> object with \"space\" and \"time\" dimension. It can be initiated manually, e.g.:</p> <pre><code># Define dimension sizes\nnspace = 10\nntime = 5\n\n# Initialte STM as Dataset\nstm = xr.Dataset(\n    data_vars=dict(\n        space_time_data=(\n            [\"space\", \"time\"],\n            np.arange(nspace * ntime).reshape((nspace, ntime)),\n        ),\n        space_data=([\"space\"], np.arange(nspace)),\n        time_data=([\"time\"], np.arange(ntime)),\n    ),\n    coords=dict(\n        x_coords=([\"space\"], np.arange(nspace)),\n        y_coords=([\"space\"], np.arange(nspace)),\n        time=([\"time\"], np.arange(ntime)),\n    ),\n)\n\nstm\n</code></pre> <pre><code>&lt;xarray.Dataset&gt;\nDimensions:          (space: 10, time: 5)\nCoordinates:\n    x_coords         (space) int64 0 1 2 3 4 5 6 7 8 9\n    y_coords         (space) int64 0 1 2 3 4 5 6 7 8 9\n  * time             (time) int64 0 1 2 3 4\nDimensions without coordinates: space\nData variables:\n    space_time_data  (space, time) int64 0 1 2 3 4 5 6 ... 43 44 45 46 47 48 49\n    space_data       (space) int64 0 1 2 3 4 5 6 7 8 9\n    time_data        (time) int64 0 1 2 3 4\n</code></pre>"},{"location":"stm_init/#from-a-zarr-storage","title":"From a Zarr storage","text":"<p>If an STM is stored in <code>.zarr</code> format, it can be read by the <code>xarray.open_zarr</code> funtcion:</p> <pre><code>stm = xr.open_zarr('./stm.zarr')\n</code></pre>"},{"location":"stm_init/#from-csv-file","title":"From csv file","text":"<p>STM can also be intiated from a csv file. During this process, the following assumptions are made to the column names of the csv file:</p> <ol> <li>All columns with space-only attributes share the same Regular Expression (RE) pattern in the column names.     E.g. Latitude, Longitude and height columns are named as \"pnt_lat\", \"pnt_lon\" and     \"pnt_height\", sharing the same RE pattern \"^pnt_\";</li> <li>Per space-time attribute, a common RE pattern is shared by all columns. E.g. for the     time-series of amplitude data, the column names are \"amp_20100101\", \"amp_20100110\",     \"amp_20100119\" ..., where \"^amp_\" is the common RE pattern;</li> <li>There is no temporal-only (i.e. 1-row attribute) attribute present in the csv file.</li> </ol> <p>Consider the example csv data. It can be loaded by <code>from_csv</code>:</p> <pre><code>import stmtools\nstm = stmtools.from_csv('example.csv')\n</code></pre> <pre><code>&lt;xarray.Dataset&gt;\nDimensions:                (space: 2500, time: 11)\nCoordinates:\n  * space                  (space) int64 0 1 2 3 4 ... 2495 2496 2497 2498 2499\n  * time                   (time) datetime64[ns] 2016-03-27 ... 2016-07-15\n    lat                    (space) float64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    lon                    (space) float64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\nData variables: (12/13)\n    pnt_id                 (space) &lt;U1 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    pnt_flags              (space) int64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    pnt_line               (space) int64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    pnt_pixel              (space) int64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    pnt_height             (space) float64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    pnt_demheight          (space) float64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    ...                     ...\n    pnt_enscoh             (space) float64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    pnt_ampconsist         (space) float64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    pnt_linear             (space) float64 dask.array&lt;chunksize=(2500,), meta=np.ndarray&gt;\n    deformation            (space, time) float64 dask.array&lt;chunksize=(2500, 11), meta=np.ndarray&gt;\n    amplitude              (space, time) float64 dask.array&lt;chunksize=(2500, 11), meta=np.ndarray&gt;\n    h2ph                   (space, time) float64 dask.array&lt;chunksize=(2500, 11), meta=np.ndarray&gt;\n</code></pre>"},{"location":"stm_init/#by-pixel-selection-from-an-image-stack","title":"By pixel selection from an image stack","text":"<p>An STM can also be generated by selecting pixels from an SLC stack or interferogram stack. An example of the selection is the <code>point_selection</code> implementation of <code>sarxarray</code>.</p>"},{"location":"notebooks/demo_stm/","title":"Example Notebook","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nimport xarray as xr\nimport numpy as np\nimport stmtools\n</pre> from pathlib import Path import xarray as xr import numpy as np import stmtools In\u00a0[2]: Copied! <pre>path_stm = Path('./stm.zarr')\nstmat = xr.open_zarr(path_stm)\nstmat = stmat.chunk({\"space\": 10000, \"time\":-1}) # Chunk 10000 space, no chunk in time\n\nprint(stmat)\n</pre> path_stm = Path('./stm.zarr') stmat = xr.open_zarr(path_stm) stmat = stmat.chunk({\"space\": 10000, \"time\":-1}) # Chunk 10000 space, no chunk in time  print(stmat) <pre>&lt;xarray.Dataset&gt;\nDimensions:    (space: 78582, time: 10)\nCoordinates:\n    azimuth    (space) int64 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n    lat        (space) float32 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n    lon        (space) float32 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n    range      (space) int64 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n  * time       (time) int64 0 1 2 3 4 5 6 7 8 9\nDimensions without coordinates: space\nData variables:\n    amplitude  (space, time) float32 dask.array&lt;chunksize=(10000, 10), meta=np.ndarray&gt;\n    complex    (space, time) complex64 dask.array&lt;chunksize=(10000, 10), meta=np.ndarray&gt;\n    phase      (space, time) float32 dask.array&lt;chunksize=(10000, 10), meta=np.ndarray&gt;\nAttributes:\n    multi-look:  coarsen-mean\n</pre> In\u00a0[3]: Copied! <pre># Path to the BRP polygon of NL\npath_polygon = Path('bag_light_AMS_WGS84.gpkg')\n</pre> # Path to the BRP polygon of NL path_polygon = Path('bag_light_AMS_WGS84.gpkg') In\u00a0[4]: Copied! <pre>stmat_subset = stmat.stm.subset(method='polygon', polygon=path_polygon)\n\nprint(stmat_subset)\n</pre> stmat_subset = stmat.stm.subset(method='polygon', polygon=path_polygon)  print(stmat_subset) <pre>&lt;xarray.Dataset&gt;\nDimensions:    (space: 26269, time: 10)\nCoordinates:\n    azimuth    (space) int64 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n    lat        (space) float32 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n    lon        (space) float32 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n    range      (space) int64 dask.array&lt;chunksize=(10000,), meta=np.ndarray&gt;\n  * time       (time) int64 0 1 2 3 4 5 6 7 8 9\nDimensions without coordinates: space\nData variables:\n    amplitude  (space, time) float32 dask.array&lt;chunksize=(10000, 10), meta=np.ndarray&gt;\n    complex    (space, time) complex64 dask.array&lt;chunksize=(10000, 10), meta=np.ndarray&gt;\n    phase      (space, time) float32 dask.array&lt;chunksize=(10000, 10), meta=np.ndarray&gt;\nAttributes:\n    multi-look:  coarsen-mean\n</pre> In\u00a0[5]: Copied! <pre>fields_to_query = ['bouwjaar']\n\nstmat_enriched = stmat_subset.stm.enrich_from_polygon(path_polygon, fields_to_query)\n</pre> fields_to_query = ['bouwjaar']  stmat_enriched = stmat_subset.stm.enrich_from_polygon(path_polygon, fields_to_query) <p>The assigined data variable <code>bouwjaar</code> will be an delayed object. We can run <code>compute</code> to peresist the value in memory:</p> In\u00a0[6]: Copied! <pre>year_construction = stmat_enriched['bouwjaar'].compute()\n</pre> year_construction = stmat_enriched['bouwjaar'].compute() In\u00a0[7]: Copied! <pre># Visualize results\nfrom matplotlib import pyplot as plt\nimport matplotlib.cm as cm\n\ncolormap = cm.jet\n\nfig, ax = plt.subplots()\nplt.title(\"Construction year, PS\")\nplt.scatter(stmat_enriched.lon.data, stmat_enriched.lat.data, c=stmat_enriched['bouwjaar'], s=0.004, cmap=colormap)\nplt.clim([1900, 2023])\nplt.colorbar()\n</pre> # Visualize results from matplotlib import pyplot as plt import matplotlib.cm as cm  colormap = cm.jet  fig, ax = plt.subplots() plt.title(\"Construction year, PS\") plt.scatter(stmat_enriched.lon.data, stmat_enriched.lat.data, c=stmat_enriched['bouwjaar'], s=0.004, cmap=colormap) plt.clim([1900, 2023]) plt.colorbar() Out[7]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x7f32383dfa30&gt;</pre>"},{"location":"notebooks/demo_stm/#example-notebook","title":"Example Notebook\u00b6","text":"<p>In this example notebook, we will demonstrate how to:</p> <ol> <li>Locate the entries in an STM which intersect building polygons;</li> <li>Add year of construction as an attribute to the STM.</li> </ol>"},{"location":"notebooks/demo_stm/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/demo_stm/#data","title":"Data\u00b6","text":"<p>Data used in this notebook can be downloaded from:</p> <ul> <li>Space-time Matrix in <code>Zarr</code> format: download;</li> <li>Bulding polygons in <code>gpkg</code> format: download.</li> </ul>"},{"location":"notebooks/demo_stm/#environment","title":"Environment\u00b6","text":"<p>For the Python environment setup, we assume you already started an independent Python environment with Python version higher than 3.10.</p> <p>To execute this notebook, install <code>stmtools</code> with the extra option <code>demo</code>:</p> <pre>pip install stmtools[demo]\n</pre> <p>After installation, execute the notebook in a JupyterLab session, which can be started by running the <code>jupyterlab</code> command in your command line:</p> <pre>jupyter-lab\n</pre> <p>A new tab will be opened in your default browser to execute this notebook.</p>"},{"location":"notebooks/demo_stm/#import-dependencies","title":"Import dependencies\u00b6","text":""},{"location":"notebooks/demo_stm/#load-space-time-matrix-from-zarr","title":"Load Space-Time Matrix from Zarr\u00b6","text":"<p>We load the STM stored in Zarr format.</p>"},{"location":"notebooks/demo_stm/#subset-by-polygon","title":"Subset by polygon\u00b6","text":"<p>We select all entries interlects the building polygons: <code>bag_light_AMS_WGS84.gpkg</code>. This takes about 2 minutes.</p>"},{"location":"notebooks/demo_stm/#stm-enrichment-from-polygon-file","title":"STM enrichment from Polygon file\u00b6","text":"<p>The year contstruction information is stored in attribute <code>bouwjaar</code> (Dutch: building year). Let's query it and assign it to the STM.</p>"},{"location":"notebooks/demo_stm/#visualize-the-results","title":"Visualize the results\u00b6","text":""}]}